# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:29:12+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity

from models import (
    ActionsGetResponse,
    ActionsIdGetResponse,
    CertificatesGetResponse,
    CertificatesIdActionsActionIdGetResponse,
    CertificatesIdActionsGetResponse,
    CertificatesIdActionsRetryPostResponse,
    CertificatesIdGetResponse,
    CertificatesIdPutRequest,
    CertificatesIdPutResponse,
    CertificatesPostRequest,
    CertificatesPostResponse,
    DatacentersGetResponse,
    DatacentersIdGetResponse,
    FirewallsGetResponse,
    FirewallsIdActionsActionIdGetResponse,
    FirewallsIdActionsApplyToResourcesPostRequest,
    FirewallsIdActionsApplyToResourcesPostResponse,
    FirewallsIdActionsGetResponse,
    FirewallsIdActionsRemoveFromResourcesPostRequest,
    FirewallsIdActionsRemoveFromResourcesPostResponse,
    FirewallsIdActionsSetRulesPostRequest,
    FirewallsIdActionsSetRulesPostResponse,
    FirewallsIdGetResponse,
    FirewallsIdPutRequest,
    FirewallsIdPutResponse,
    FirewallsPostRequest,
    FirewallsPostResponse,
    FloatingIpsGetResponse,
    FloatingIpsIdActionsActionIdGetResponse,
    FloatingIpsIdActionsAssignPostRequest,
    FloatingIpsIdActionsAssignPostResponse,
    FloatingIpsIdActionsChangeDnsPtrPostRequest,
    FloatingIpsIdActionsChangeDnsPtrPostResponse,
    FloatingIpsIdActionsChangeProtectionPostRequest,
    FloatingIpsIdActionsChangeProtectionPostResponse,
    FloatingIpsIdActionsGetResponse,
    FloatingIpsIdActionsUnassignPostResponse,
    FloatingIpsIdGetResponse,
    FloatingIpsIdPutRequest,
    FloatingIpsIdPutResponse,
    FloatingIpsPostRequest,
    FloatingIpsPostResponse,
    ImagesGetResponse,
    ImagesIdActionsActionIdGetResponse,
    ImagesIdActionsChangeProtectionPostRequest,
    ImagesIdActionsChangeProtectionPostResponse,
    ImagesIdActionsGetResponse,
    ImagesIdGetResponse,
    ImagesIdPutRequest,
    ImagesIdPutResponse,
    IsosGetResponse,
    IsosIdGetResponse,
    LoadBalancersGetResponse,
    LoadBalancersIdActionsActionIdGetResponse,
    LoadBalancersIdActionsAddServicePostRequest,
    LoadBalancersIdActionsAddServicePostResponse,
    LoadBalancersIdActionsAddTargetPostRequest,
    LoadBalancersIdActionsAddTargetPostResponse,
    LoadBalancersIdActionsAttachToNetworkPostRequest,
    LoadBalancersIdActionsAttachToNetworkPostResponse,
    LoadBalancersIdActionsChangeAlgorithmPostRequest,
    LoadBalancersIdActionsChangeAlgorithmPostResponse,
    LoadBalancersIdActionsChangeDnsPtrPostRequest,
    LoadBalancersIdActionsChangeDnsPtrPostResponse,
    LoadBalancersIdActionsChangeProtectionPostRequest,
    LoadBalancersIdActionsChangeProtectionPostResponse,
    LoadBalancersIdActionsChangeTypePostRequest,
    LoadBalancersIdActionsChangeTypePostResponse,
    LoadBalancersIdActionsDeleteServicePostRequest,
    LoadBalancersIdActionsDeleteServicePostResponse,
    LoadBalancersIdActionsDetachFromNetworkPostRequest,
    LoadBalancersIdActionsDetachFromNetworkPostResponse,
    LoadBalancersIdActionsDisablePublicInterfacePostResponse,
    LoadBalancersIdActionsEnablePublicInterfacePostResponse,
    LoadBalancersIdActionsGetResponse,
    LoadBalancersIdActionsRemoveTargetPostRequest,
    LoadBalancersIdActionsRemoveTargetPostResponse,
    LoadBalancersIdActionsUpdateServicePostRequest,
    LoadBalancersIdActionsUpdateServicePostResponse,
    LoadBalancersIdGetResponse,
    LoadBalancersIdMetricsGetResponse,
    LoadBalancersIdPutRequest,
    LoadBalancersIdPutResponse,
    LoadBalancersPostRequest,
    LoadBalancersPostResponse,
    LoadBalancerTypesGetResponse,
    LoadBalancerTypesIdGetResponse,
    LocationsGetResponse,
    LocationsIdGetResponse,
    NetworksGetResponse,
    NetworksIdActionsActionIdGetResponse,
    NetworksIdActionsAddRoutePostRequest,
    NetworksIdActionsAddRoutePostResponse,
    NetworksIdActionsAddSubnetPostRequest,
    NetworksIdActionsAddSubnetPostResponse,
    NetworksIdActionsChangeIpRangePostRequest,
    NetworksIdActionsChangeIpRangePostResponse,
    NetworksIdActionsChangeProtectionPostRequest,
    NetworksIdActionsChangeProtectionPostResponse,
    NetworksIdActionsDeleteRoutePostRequest,
    NetworksIdActionsDeleteRoutePostResponse,
    NetworksIdActionsDeleteSubnetPostRequest,
    NetworksIdActionsDeleteSubnetPostResponse,
    NetworksIdActionsGetResponse,
    NetworksIdGetResponse,
    NetworksIdPutRequest,
    NetworksIdPutResponse,
    NetworksPostRequest,
    NetworksPostResponse,
    PlacementGroupsGetResponse,
    PlacementGroupsIdGetResponse,
    PlacementGroupsIdPutRequest,
    PlacementGroupsIdPutResponse,
    PlacementGroupsPostRequest,
    PlacementGroupsPostResponse,
    PricingGetResponse,
    PrimaryIpsGetResponse,
    PrimaryIpsIdActionsAssignPostRequest,
    PrimaryIpsIdActionsAssignPostResponse,
    PrimaryIpsIdActionsChangeDnsPtrPostRequest,
    PrimaryIpsIdActionsChangeDnsPtrPostResponse,
    PrimaryIpsIdActionsChangeProtectionPostRequest,
    PrimaryIpsIdActionsChangeProtectionPostResponse,
    PrimaryIpsIdActionsUnassignPostResponse,
    PrimaryIpsIdGetResponse,
    PrimaryIpsIdPutRequest,
    PrimaryIpsIdPutResponse,
    PrimaryIpsPostRequest,
    PrimaryIpsPostResponse,
    ServersGetResponse,
    ServersIdActionsActionIdGetResponse,
    ServersIdActionsAddToPlacementGroupPostRequest,
    ServersIdActionsAddToPlacementGroupPostResponse,
    ServersIdActionsAttachIsoPostRequest,
    ServersIdActionsAttachIsoPostResponse,
    ServersIdActionsAttachToNetworkPostRequest,
    ServersIdActionsAttachToNetworkPostResponse,
    ServersIdActionsChangeAliasIpsPostRequest,
    ServersIdActionsChangeAliasIpsPostResponse,
    ServersIdActionsChangeDnsPtrPostRequest,
    ServersIdActionsChangeDnsPtrPostResponse,
    ServersIdActionsChangeProtectionPostRequest,
    ServersIdActionsChangeProtectionPostResponse,
    ServersIdActionsChangeTypePostRequest,
    ServersIdActionsChangeTypePostResponse,
    ServersIdActionsCreateImagePostRequest,
    ServersIdActionsCreateImagePostResponse,
    ServersIdActionsDetachFromNetworkPostRequest,
    ServersIdActionsDetachFromNetworkPostResponse,
    ServersIdActionsDetachIsoPostResponse,
    ServersIdActionsDisableBackupPostResponse,
    ServersIdActionsDisableRescuePostResponse,
    ServersIdActionsEnableBackupPostResponse,
    ServersIdActionsEnableRescuePostRequest,
    ServersIdActionsEnableRescuePostResponse,
    ServersIdActionsGetResponse,
    ServersIdActionsPoweroffPostResponse,
    ServersIdActionsPoweronPostResponse,
    ServersIdActionsRebootPostResponse,
    ServersIdActionsRebuildPostRequest,
    ServersIdActionsRebuildPostResponse,
    ServersIdActionsRemoveFromPlacementGroupPostResponse,
    ServersIdActionsRequestConsolePostResponse,
    ServersIdActionsResetPasswordPostResponse,
    ServersIdActionsResetPostResponse,
    ServersIdActionsShutdownPostResponse,
    ServersIdDeleteResponse,
    ServersIdGetResponse,
    ServersIdMetricsGetResponse,
    ServersIdPutRequest,
    ServersIdPutResponse,
    ServersPostRequest,
    ServersPostResponse,
    ServerTypesGetResponse,
    ServerTypesIdGetResponse,
    Sort,
    Sort2,
    Sort4,
    Sort6,
    Sort8,
    Sort10,
    Sort12,
    Sort14,
    Sort16,
    Sort18,
    Sort20,
    Sort24,
    Sort26,
    Sort28,
    Sort30,
    Sort32,
    Sort34,
    Sort36,
    SshKeysGetResponse,
    SshKeysIdGetResponse,
    SshKeysIdPutRequest,
    SshKeysIdPutResponse,
    SshKeysPostRequest,
    SshKeysPostResponse,
    Status2,
    Status11,
    Status17,
    Status25,
    Status33,
    Status38,
    Status54,
    Status71,
    Status89,
    Status104,
    Status132,
    Status140,
    Type,
    Type25,
    Type44,
    Type52,
    Type81,
    VolumesGetResponse,
    VolumesIdActionsActionIdGetResponse,
    VolumesIdActionsAttachPostRequest,
    VolumesIdActionsAttachPostResponse,
    VolumesIdActionsChangeProtectionPostRequest,
    VolumesIdActionsChangeProtectionPostResponse,
    VolumesIdActionsDetachPostResponse,
    VolumesIdActionsGetResponse,
    VolumesIdActionsResizePostRequest,
    VolumesIdActionsResizePostResponse,
    VolumesIdGetResponse,
    VolumesIdPutRequest,
    VolumesIdPutResponse,
    VolumesPostRequest,
    VolumesPostResponse,
)

app = MCPProxy(
    description='This is the official API documentation for the Public Hetzner Cloud.\n\n## Introduction\n\nThe Hetzner Cloud API operates over HTTPS and uses JSON as its data format. The API is a RESTful API and utilizes HTTP methods and HTTP status codes to specify requests and responses.\n\nAs an alternative to working directly with our API you may also consider to use:\n* Our CLI program [hcloud](https://github.com/hetznercloud/cli)\n* Our [library for Go](https://github.com/hetznercloud/hcloud-go)\n* Our [library for Python](https://github.com/hetznercloud/hcloud-python)\n\nAlso you can find a [list of libraries, tools, and integrations on GitHub](https://github.com/hetznercloud/awesome-hcloud).\n\nIf you are developing integrations based on our API and your product is Open Source you may be eligible for a free one time €50 (excl. VAT) credit on your account. Please contact us via the the support page on your Cloud Console and let us know the following:\n* The type of integration you would like to develop\n* Link to the GitHub repo you will use for the Project\n* Link to some other Open Source work you have already done (if you have done so)\n\n## Getting Started\nTo get started using the API you first need an API token. Sign in into the [Hetzner Cloud Console](https://console.hetzner.cloud/) choose a Project, go to `Security` → `API Tokens`, and generate a new token. Make sure to copy the token because it won’t be shown to you again. A token is bound to a Project, to interact with the API of another Project you have to create a new token inside the Project. Let’s say your new token is `jEheVytlAoFl7F8MqUQ7jAo2hOXASztX`.\n\nYou’re now ready to do your first request against the API. To get a list of all Servers in your Project, issue the example request on the right side using [curl](https://curl.haxx.se/).\n\nMake sure to replace the token in the example command with the token you have just created. Since your Project probably does not contain any Servers yet, the example response will look like the response on the right side. We will almost always provide a resource root like `servers` inside the example response. A response can also contain a `meta` object with information like [Pagination](https://docs.hetzner.cloud/#overview-pagination).\n\n**Example Request**\n```bash\ncurl -H "Authorization: Bearer jEheVytlAoFl7F8MqUQ7jAo2hOXASztX" \\\n    https://api.hetzner.cloud/v1/servers\n```\n\n**Example Response**\n```json\n{\n    "servers": [],\n    "meta": {\n        "pagination": {\n            "page": 1,\n            "per_page": 25,\n            "previous_page": null,\n            "next_page": null,\n            "last_page": 1,\n            "total_entries": 0\n        }\n    }\n}\n```\n\n## Authentication\nAll requests to the Hetzner Cloud API must be authenticated via a API token. Include your secret API token in every request you send to the API with the `Authorization` HTTP header.\n\nTo create a new API token for your Project, switch into the [Hetzner Cloud Console](https://console.hetzner.cloud/) choose a Project, go to `Security` → `API Tokens`, and generate a new token.\n\n**Example Authorization header**\n```html\nAuthorization: Bearer LRK9DAWQ1ZAEFSrCNEEzLCUwhYX1U3g7wMg4dTlkkDC96fyDuyJ39nVbVjCKSDfj\n```\n\n## Errors\nErrors are indicated by HTTP status codes. Further, the response of the request which generated the error contains an error code, an error message, and, optionally, error details. The schema of the error details object depends on the error code.\n\nThe error response contains the following keys:\n\n| Keys      | Meaning                                                               |\n|-----------|-----------------------------------------------------------------------|\n| `code`    | Short string indicating the type of error (machine-parsable)          |\n| `message` | Textual description on what has gone wrong                            |\n| `details` | An object providing for details on the error (schema depends on code) |\n\n**Example response**\n```json\n{\n  "error": {\n    "code": "invalid_input",\n    "message": "invalid input in field \'broken_field\': is too long",\n    "details": {\n      "fields": [\n        {\n          "name": "broken_field",\n          "messages": ["is too long"]\n        }\n      ]\n    }\n  }\n}\n```\n\n### Error Codes\n\n| Code                      | Description                                                                      |\n|---------------------------|----------------------------------------------------------------------------------|\n| `forbidden`               | Insufficient permissions for this request                                        |\n| `invalid_input`           | Error while parsing or processing the input                                      |\n| `json_error`              | Invalid JSON input in your request                                               |\n| `locked`                  | The item you are trying to access is locked (there is already an Action running) |\n| `not_found`               | Entity not found                                                                 |\n| `rate_limit_exceeded`     | Error when sending too many requests                                             |\n| `resource_limit_exceeded` | Error when exceeding the maximum quantity of a resource for an account           |\n| `resource_unavailable`    | The requested resource is currently unavailable                                  |\n| `service_error`           | Error within a service                                                           |\n| `uniqueness_error`        | One or more of the objects fields must be unique                                 |\n| `protected`               | The Action you are trying to start is protected for this resource                |\n| `maintenance`             | Cannot perform operation due to maintenance                                      |\n| `conflict`                | The resource has changed during the request, please retry                        |\n| `unsupported_error`       | The corresponding resource does not support the Action                           |\n| `token_readonly`          | The token is only allowed to perform GET requests                                |\n| `unavailable`             | A service or product is currently not available                                  |\n\n**invalid_input**\n```json\n{\n  "error": {\n    "code": "invalid_input",\n    "message": "invalid input in field \'broken_field\': is too long",\n    "details": {\n      "fields": [\n        {\n          "name": "broken_field",\n          "messages": ["is too long"]\n        }\n      ]\n    }\n  }\n}\n```\n\n**uniqueness_error**\n```json\n{\n  "error": {\n    "code": "uniqueness_error",\n    "message": "SSH key with the same fingerprint already exists",\n    "details": {\n      "fields": [\n        {\n          "name": "public_key"\n        }\n      ]\n    }\n  }\n}\n```\n\n**resource_limit_exceeded**\n```json\n{\n  "error": {\n    "code": "resource_limit_exceeded",\n    "message": "project limit exceeded",\n    "details": {\n      "limits": [\n        {\n          "name": "project_limit"\n        }\n      ]\n    }\n  }\n}\n```\n\n## Labels\nLabels are `key/value` pairs that can be attached to all resources.\n\nValid label keys have two segments: an optional prefix and name, separated by a slash (`/`). The name segment is required and must be a string of 63 characters or less, beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between. The prefix is optional. If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (`.`), not longer than 253 characters in total, followed by a slash (`/`).\n\nValid label values must be a string of 63 characters or less and must be empty or begin and end with an alphanumeric character (`[a-z0-9A-Z]`) with dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.\n\nThe `hetzner.cloud/` prefix is reserved and cannot be used.\n\n**Example Labels**\n```json\n{\n  "labels": {\n    "environment":"development",\n    "service":"backend",\n    "example.com/my":"label",\n    "just-a-key":""\n  }\n}\n```\n\n## Label Selector\nFor resources with labels, you can filter resources by their labels using the label selector query language.\n\n| Expression           | Meaning                                                             |\n|----------------------|---------------------------------------------------------------------|\n| `k==v` / `k=v`       | Value of key `k` does equal value `v`                               |\n| `k!=v`               | Value of key `k` does not equal value `v`                           |\n| `k`                  | Key `k` is present                                                  |\n| `!k`                 | Key `k` is not present                                              |\n| `k in (v1,v2,v3)`    | Value of key `k` is `v1`, `v2`, or `v3`                             |\n| `k notin (v1,v2,v3)` | Value of key `k` is neither `v1`, nor `v2`, nor `v3`                |\n| `k1==v,!k2`          | Value of key `k1` is `v` and key `k2` is not present                |\n\n### Examples\n* Returns all resources that have a `env=production` label and that don\'t have a `type=database` label:\n\n  `env=production,type!=database`\n* Returns all resources that have a `env=testing` or `env=staging` label:\n\n    `env in (testing,staging)`\n* Returns all resources that don\'t have a `type` label:\n\n    `!type`\n\n## Pagination\nResponses which return multiple items support pagination. If they do support pagination, it can be controlled with following query string parameters:\n\n* A `page` parameter specifies the page to fetch. The number of the first page is 1.\n* A `per_page` parameter specifies the number of items returned per page. The default value is 25, the maximum value is 50 except otherwise specified in the documentation.\n\nResponses contain a `Link` header with pagination information.\n\nAdditionally, if the response body is JSON and the root object is an object, that object has a `pagination` object inside the `meta` object with pagination information:\n\n**Example Pagination**\n```json\n{\n    "servers": [...],\n    "meta": {\n        "pagination": {\n            "page": 2,\n            "per_page": 25,\n            "previous_page": 1,\n            "next_page": 3,\n            "last_page": 4,\n            "total_entries": 100\n        }\n    }\n}\n```\n\nThe keys `previous_page`, `next_page`, `last_page`, and `total_entries` may be `null` when on the first page, last page, or when the total number of entries is unknown.\n\n**Example Pagination Link header**\n```bash\nLink: <https://api.hetzner.cloud/v1/actions?page=2&per_page=5>; rel="prev",\n      <https://api.hetzner.cloud/v1/actions?page=4&per_page=5>; rel="next",\n      <https://api.hetzner.cloud/v1/actions?page=6&per_page=5>; rel="last"\n```\n\nLine breaks have been added for display purposes only and responses may only contain some of the above `rel` values.\n\n## Rate Limiting\nAll requests, whether they are authenticated or not, are subject to rate limiting. If you have reached your limit, your requests will be handled with a `429 Too Many Requests` error. Burst requests are allowed. Responses contain serveral headers which provide information about your current rate limit status.\n\n* The `RateLimit-Limit` header contains the total number of requests you can perform per hour.\n* The `RateLimit-Remaining` header contains the number of requests remaining in the current rate limit time frame.\n* The `RateLimit-Reset` header contains a UNIX timestamp of the point in time when your rate limit will have recovered and you will have the full number of requests available again.\n\nThe default limit is 3600 requests per hour and per Project. The number of remaining requests increases gradually. For example, when your limit is 3600 requests per hour, the number of remaining requests will increase by 1 every second.\n\n## Server Metadata\nYour Server can discover metadata about itself by doing a HTTP request to specific URLs. The following data is available:\n\n| Data              | Format | Contents                                                     |\n|-------------------|--------|--------------------------------------------------------------|\n| hostname          | text   | Name of the Server as set in the api                         |\n| instance-id       | number | ID of the server                                             |\n| public-ipv4       | text   | Primary public IPv4 address                                  |\n| private-networks  | yaml   | Details about the private networks the Server is attached to |\n| availability-zone | text   | Name of the availability zone that Server runs in            |\n| region            | text   | Network zone, e.g. eu-central                                |\n\n**Example: Summary**\n```bash\n$ curl http://169.254.169.254/hetzner/v1/metadata\n```\n\n```yaml\navailability-zone: hel1-dc2\nhostname: my-server\ninstance-id: 42\npublic-ipv4: 1.2.3.4\nregion: eu-central\n```\n\n**Example: Hostname**\n```bash\n$ curl http://169.254.169.254/hetzner/v1/metadata/hostname\nmy-server\n```\n\n**Example: Instance ID**\n```bash\n$ curl http://169.254.169.254/hetzner/v1/metadata/instance-id\n42\n```\n\n**Example: Public IPv4**\n```bash\n$ curl http://169.254.169.254/hetzner/v1/metadata/public-ipv4\n1.2.3.4\n```\n\n**Example: Private Networks**\n```bash\n$ curl http://169.254.169.254/hetzner/v1/metadata/private-networks\n```\n\n```json\n- ip: 10.0.0.2\n  alias_ips: [10.0.0.3, 10.0.0.4]\n  interface_num: 1\n  mac_address: 86:00:00:2a:7d:e0\n  network_id: 1234\n  network_name: nw-test1\n  network: 10.0.0.0/8\n  subnet: 10.0.0.0/24\n  gateway: 10.0.0.1\n- ip: 192.168.0.2\n  alias_ips: []\n  interface_num: 2\n  mac_address: 86:00:00:2a:7d:e1\n  network_id: 4321\n  network_name: nw-test2\n  network: 192.168.0.0/16\n  subnet: 192.168.0.0/24\n  gateway: 192.168.0.1\n```\n\n**Example: Availability Zone**\n```bash\n$ curl http://169.254.169.254/hetzner/v1/metadata/availability-zone\nhel1-dc2\n```\n\n**Example: Region**\n```bash\n$ curl http://169.254.169.254/hetzner/v1/metadata/region\neu-central\n```\n\n## Sorting\nSome responses which return multiple items support sorting. If they do support sorting the documentation states which fields can be used for sorting. You specify sorting with the `sort` query string parameter. You can sort by multiple fields. You can set the sort direction by appending `:asc` or `:desc` to the field name. By default, ascending sorting is used.\n\n**Example: Sorting**\n```bash\nhttps://api.hetzner.cloud/v1/actions?sort=status\nhttps://api.hetzner.cloud/v1/actions?sort=status:asc\nhttps://api.hetzner.cloud/v1/actions?sort=status:desc\nhttps://api.hetzner.cloud/v1/actions?sort=status:asc&sort=command:desc\n```\n',
    title='Hetzner Cloud API',
    version='1.0.0',
    servers=[{'url': 'https://api.hetzner.cloud/v1'}],
)


@app.get(
    '/actions',
    description=""" Returns all Action objects. You can `sort` the results by using the sort URI parameter, and filter them with the `status` parameter. """,
    tags=['action_management'],
)
def get_actions(
    id: Optional[int] = None,
    sort: Optional[Sort] = None,
    status: Optional[Status2] = None,
):
    """
    Get all Actions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/actions/{id}',
    description=""" Returns a specific Action object. """,
    tags=['action_management'],
)
def get_actions__id(id: int):
    """
    Get an Action
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/certificates',
    description=""" Returns all Certificate objects. """,
    tags=['certificate_management', 'action_management'],
)
def get_certificates(
    sort: Optional[Sort2] = None,
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
    type: Optional[Type] = None,
):
    """
    Get all Certificates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/certificates',
    description=""" Creates a new Certificate.

The default type **uploaded** allows for uploading your existing `certificate` and `private_key` in PEM format. You have to monitor its expiration date and handle renewal yourself.

In contrast, type **managed** requests a new Certificate from *Let's Encrypt* for the specified `domain_names`. Only domains managed by *Hetzner DNS* are supported. We handle renewal and timely alert the project owner via email if problems occur.

For type `managed` Certificates the `action` key of the response contains the Action that allows for tracking the issuance process. For type `uploaded` Certificates the `action` is always null.
 """,
    tags=['certificate_management', 'action_management'],
)
def post_certificates(body: CertificatesPostRequest = None):
    """
    Create a Certificate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/certificates/{id}',
    description=""" Deletes a Certificate. """,
    tags=['certificate_management', 'action_management'],
)
def delete_certificates__id(id: int):
    """
    Delete a Certificate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/certificates/{id}',
    description=""" Gets a specific Certificate object. """,
    tags=['certificate_management', 'action_management'],
)
def get_certificates__id(id: int):
    """
    Get a Certificate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/certificates/{id}',
    description=""" Updates the Certificate properties.

Note that when updating labels, the Certificate’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.

Note: if the Certificate object changes during the request, the response will be a “conflict” error.
 """,
    tags=['certificate_management', 'action_management'],
)
def put_certificates__id(id: int, body: CertificatesIdPutRequest = None):
    """
    Update a Certificate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/certificates/{id}/actions',
    description=""" Returns all Action objects for a Certificate. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter.

Only type `managed` Certificates can have Actions. For type `uploaded` Certificates the `actions` key will always contain an empty array.
 """,
    tags=['action_management', 'certificate_management'],
)
def get_certificates__id_actions(
    id: int, sort: Optional[Sort4] = None, status: Optional[Status11] = None
):
    """
    Get all Actions for a Certificate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/certificates/{id}/actions/retry',
    description=""" Retry a failed Certificate issuance or renewal.

Only applicable if the type of the Certificate is `managed` and the issuance or renewal status is `failed`.

#### Call specific error codes

| Code                                                    | Description                                                               |
|---------------------------------------------------------|---------------------------------------------------------------------------|
| `caa_record_does_not_allow_ca`                          | CAA record does not allow certificate authority                           |
| `ca_dns_validation_failed`                              | Certificate Authority: DNS validation failed                              |
| `ca_too_many_authorizations_failed_recently`            | Certificate Authority: Too many authorizations failed recently            |
| `ca_too_many_certificates_issued_for_registered_domain` | Certificate Authority: Too many certificates issued for registered domain |
| `ca_too_many_duplicate_certificates`                    | Certificate Authority: Too many duplicate certificates                    |
| `could_not_verify_domain_delegated_to_zone`             | Could not verify domain delegated to zone                                 |
| `dns_zone_not_found`                                    | DNS zone not found                                                        |
| `dns_zone_is_secondary_zone`                            | DNS zone is a secondary zone                                              |
 """,
    tags=['certificate_management', 'action_management'],
)
def post_certificates__id_actions_retry(id: int):
    """
    Retry Issuance or Renewal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/certificates/{id}/actions/{action_id}',
    description=""" Returns a specific Action for a Certificate. Only type `managed` Certificates have Actions. """,
    tags=['action_management', 'certificate_management'],
)
def get_certificates__id_actions__action_id(id: int, action_id: int = ...):
    """
    Get an Action for a Certificate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datacenters',
    description=""" Returns all Datacenter objects. """,
    tags=['datacenter_management'],
)
def get_datacenters(name: Optional[str] = None):
    """
    Get all Datacenters
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/datacenters/{id}',
    description=""" Returns a specific Datacenter object. """,
    tags=['datacenter_management'],
)
def get_datacenters__id(id: int):
    """
    Get a Datacenter
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/firewalls',
    description=""" Returns all Firewall objects. """,
    tags=['action_management', 'firewall_management'],
)
def get_firewalls(
    sort: Optional[Sort6] = None,
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
):
    """
    Get all Firewalls
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/firewalls',
    description=""" Creates a new Firewall.

#### Call specific error codes

| Code                          | Description                                                   |
|------------------------------ |-------------------------------------------------------------- |
| `server_already_added`        | Server added more than one time to resource                   |
| `incompatible_network_type`   | The Network type is incompatible for the given resource       |
| `firewall_resource_not_found` | The resource the Firewall should be attached to was not found |
 """,
    tags=['firewall_management'],
)
def post_firewalls(body: FirewallsPostRequest = None):
    """
    Create a Firewall
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/firewalls/{id}',
    description=""" Deletes a Firewall.

#### Call specific error codes

| Code                 | Description                               |
|--------------------- |-------------------------------------------|
| `resource_in_use`    | Firewall must not be in use to be deleted |
 """,
    tags=['firewall_management'],
)
def delete_firewalls__id(id: int):
    """
    Delete a Firewall
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/firewalls/{id}',
    description=""" Gets a specific Firewall object. """,
    tags=['firewall_management', 'action_management'],
)
def get_firewalls__id(id: int):
    """
    Get a Firewall
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/firewalls/{id}',
    description=""" Updates the Firewall.

Note that when updating labels, the Firewall's current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.

Note: if the Firewall object changes during the request, the response will be a “conflict” error.
 """,
    tags=['firewall_management'],
)
def put_firewalls__id(id: int, body: FirewallsIdPutRequest = None):
    """
    Update a Firewall
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/firewalls/{id}/actions',
    description=""" Returns all Action objects for a Firewall. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter. """,
    tags=['action_management', 'firewall_management'],
)
def get_firewalls__id_actions(
    id: int, sort: Optional[Sort8] = None, status: Optional[Status17] = None
):
    """
    Get all Actions for a Firewall
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/firewalls/{id}/actions/apply_to_resources',
    description=""" Applies one Firewall to multiple resources.

Currently servers (public network interface) and label selectors are supported.

#### Call specific error codes

| Code                          | Description                                                   |
|-------------------------------|---------------------------------------------------------------|
| `firewall_already_applied`    | Firewall was already applied on resource                      |
| `incompatible_network_type`   | The Network type is incompatible for the given resource       |
| `firewall_resource_not_found` | The resource the Firewall should be attached to was not found |
 """,
    tags=['action_management', 'firewall_management'],
)
def post_firewalls__id_actions_apply_to_resources(
    id: int, body: FirewallsIdActionsApplyToResourcesPostRequest = None
):
    """
    Apply to Resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/firewalls/{id}/actions/remove_from_resources',
    description=""" Removes one Firewall from multiple resources.

Currently only Servers (and their public network interfaces) are supported.

#### Call specific error codes

| Code                                  | Description                                                            |
|---------------------------------------|------------------------------------------------------------------------|
| `firewall_already_removed`            | Firewall was already removed from the resource                         |
| `firewall_resource_not_found`         | The resource the Firewall should be attached to was not found          |
| `firewall_managed_by_label_selector`  | Firewall was applied via label selector and cannot be removed manually |
 """,
    tags=['action_management', 'firewall_management'],
)
def post_firewalls__id_actions_remove_from_resources(
    id: int, body: FirewallsIdActionsRemoveFromResourcesPostRequest = None
):
    """
    Remove from Resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/firewalls/{id}/actions/set_rules',
    description=""" Sets the rules of a Firewall.

All existing rules will be overwritten. Pass an empty `rules` array to remove all rules.
The maximum amount of rules that can be defined is 50.

#### Call specific error codes

| Code                          | Description                                                   |
|-------------------------------|---------------------------------------------------------------|
| `firewall_resource_not_found` | The resource the Firewall should be attached to was not found |
 """,
    tags=['action_management', 'firewall_management'],
)
def post_firewalls__id_actions_set_rules(
    id: int, body: FirewallsIdActionsSetRulesPostRequest = None
):
    """
    Set Rules
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/firewalls/{id}/actions/{action_id}',
    description=""" Returns a specific Action for a Firewall. """,
    tags=['action_management', 'firewall_management'],
)
def get_firewalls__id_actions__action_id(id: int, action_id: int = ...):
    """
    Get an Action for a Firewall
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/floating_ips',
    description=""" Returns all Floating IP objects. """,
    tags=['action_management', 'floating_ip_management'],
)
def get_floating_ips(
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
    sort: Optional[Sort10] = None,
):
    """
    Get all Floating IPs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/floating_ips',
    description=""" Creates a new Floating IP assigned to a Server. If you want to create a Floating IP that is not bound to a Server, you need to provide the `home_location` key instead of `server`. This can be either the ID or the name of the Location this IP shall be created in. Note that a Floating IP can be assigned to a Server in any Location later on. For optimal routing it is advised to use the Floating IP in the same Location it was created in. """,
    tags=['action_management', 'floating_ip_management'],
)
def post_floating_ips(body: FloatingIpsPostRequest = None):
    """
    Create a Floating IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/floating_ips/{id}',
    description=""" Deletes a Floating IP. If it is currently assigned to a Server it will automatically get unassigned. """,
    tags=['action_management', 'floating_ip_management'],
)
def delete_floating_ips__id(id: int):
    """
    Delete a Floating IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/floating_ips/{id}',
    description=""" Returns a specific Floating IP object. """,
    tags=['floating_ip_management', 'action_management'],
)
def get_floating_ips__id(id: int):
    """
    Get a Floating IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/floating_ips/{id}',
    description=""" Updates the description or labels of a Floating IP.
Also note that when updating labels, the Floating IP’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body. """,
    tags=['action_management', 'floating_ip_management'],
)
def put_floating_ips__id(id: int, body: FloatingIpsIdPutRequest = None):
    """
    Update a Floating IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/floating_ips/{id}/actions',
    description=""" Returns all Action objects for a Floating IP. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter. """,
    tags=['action_management', 'floating_ip_management'],
)
def get_floating_ips__id_actions(
    id: int, sort: Optional[Sort12] = None, status: Optional[Status25] = None
):
    """
    Get all Actions for a Floating IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/floating_ips/{id}/actions/assign',
    description=""" Assigns a Floating IP to a Server. """,
    tags=[
        'action_management',
        'floating_ip_management',
        'server_management',
        'server_actions',
    ],
)
def post_floating_ips__id_actions_assign(
    id: int, body: FloatingIpsIdActionsAssignPostRequest = None
):
    """
    Assign a Floating IP to a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/floating_ips/{id}/actions/change_dns_ptr',
    description=""" Changes the hostname that will appear when getting the hostname belonging to this Floating IP. """,
    tags=['action_management', 'floating_ip_management'],
)
def post_floating_ips__id_actions_change_dns_ptr(
    id: int, body: FloatingIpsIdActionsChangeDnsPtrPostRequest = None
):
    """
    Change reverse DNS entry for a Floating IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/floating_ips/{id}/actions/change_protection',
    description=""" Changes the protection configuration of the Floating IP. """,
    tags=['action_management', 'floating_ip_management'],
)
def post_floating_ips__id_actions_change_protection(
    id: int, body: FloatingIpsIdActionsChangeProtectionPostRequest = None
):
    """
    Change Floating IP Protection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/floating_ips/{id}/actions/unassign',
    description=""" Unassigns a Floating IP, resulting in it being unreachable. You may assign it to a Server again at a later time. """,
    tags=['floating_ip_management', 'action_management'],
)
def post_floating_ips__id_actions_unassign(id: int):
    """
    Unassign a Floating IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/floating_ips/{id}/actions/{action_id}',
    description=""" Returns a specific Action object for a Floating IP. """,
    tags=['action_management', 'floating_ip_management'],
)
def get_floating_ips__id_actions__action_id(id: int, action_id: int = ...):
    """
    Get an Action for a Floating IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images',
    description=""" Returns all Image objects. You can select specific Image types only and sort the results by using URI parameters. """,
    tags=['image_management'],
)
def get_images(
    sort: Optional[Sort14] = None,
    type: Optional[Type25] = None,
    status: Optional[Status33] = None,
    bound_to: Optional[str] = None,
    include_deprecated: Optional[bool] = None,
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
):
    """
    Get all Images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/images/{id}',
    description=""" Deletes an Image. Only Images of type `snapshot` and `backup` can be deleted. """,
    tags=['image_management'],
)
def delete_images__id(id: int):
    """
    Delete an Image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{id}',
    description=""" Returns a specific Image object. """,
    tags=['image_management'],
)
def get_images__id(id: int):
    """
    Get an Image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/images/{id}',
    description=""" Updates the Image. You may change the description, convert a Backup Image to a Snapshot Image or change the Image labels. Only Images of type `snapshot` and `backup` can be updated.

Note that when updating labels, the current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
 """,
    tags=['image_management'],
)
def put_images__id(id: int, body: ImagesIdPutRequest = None):
    """
    Update an Image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{id}/actions',
    description=""" Returns all Action objects for an Image. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter. """,
    tags=['image_management', 'action_management'],
)
def get_images__id_actions(
    id: int, sort: Optional[Sort16] = None, status: Optional[Status38] = None
):
    """
    Get all Actions for an Image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/images/{id}/actions/change_protection',
    description=""" Changes the protection configuration of the Image. Can only be used on snapshots. """,
    tags=['image_management', 'action_management'],
)
def post_images__id_actions_change_protection(
    id: int, body: ImagesIdActionsChangeProtectionPostRequest = None
):
    """
    Change Image Protection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{id}/actions/{action_id}',
    description=""" Returns a specific Action for an Image. """,
    tags=['image_management', 'action_management'],
)
def get_images__id_actions__action_id(id: int, action_id: int = ...):
    """
    Get an Action for an Image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/isos',
    description=""" Returns all available ISO objects. """,
    tags=['iso_management'],
)
def get_isos(name: Optional[str] = None):
    """
    Get all ISOs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/isos/{id}',
    description=""" Returns a specific ISO object. """,
    tags=['iso_management'],
)
def get_isos__id(id: int):
    """
    Get an ISO
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/load_balancer_types',
    description=""" Gets all Load Balancer type objects. """,
    tags=['load_balancer_type_management', 'load_balancer_management'],
)
def get_load_balancer_types(name: Optional[str] = None):
    """
    Get all Load Balancer Types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/load_balancer_types/{id}',
    description=""" Gets a specific Load Balancer type object. """,
    tags=['load_balancer_type_management', 'load_balancer_management'],
)
def get_load_balancer_types__id(id: int):
    """
    Get a Load Balancer Type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/load_balancers',
    description=""" Gets all existing Load Balancers that you have available. """,
    tags=['load_balancer_management', 'load_balancer_operations'],
)
def get_load_balancers(
    sort: Optional[Sort18] = None,
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
):
    """
    Get all Load Balancers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers',
    description=""" Creates a Load Balancer.

#### Call specific error codes

| Code                                    | Description                                                                                           |
|-----------------------------------------|-------------------------------------------------------------------------------------------------------|
| `cloud_resource_ip_not_allowed`         | The IP you are trying to add as a target belongs to a Hetzner Cloud resource                          |
| `ip_not_owned`                          | The IP is not owned by the owner of the project of the Load Balancer                                  |
| `load_balancer_not_attached_to_network` | The Load Balancer is not attached to a network                                                        |
| `robot_unavailable`                     | Robot was not available. The caller may retry the operation after a short delay.                      |
| `server_not_attached_to_network`        | The server you are trying to add as a target is not attached to the same network as the Load Balancer |
| `source_port_already_used`              | The source port you are trying to add is already in use                                               |
| `target_already_defined`                | The Load Balancer target you are trying to define is already defined                                  |
 """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'load_balancer_operations',
        'load_balancer_type_management',
    ],
)
def post_load_balancers(body: LoadBalancersPostRequest = None):
    """
    Create a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/load_balancers/{id}',
    description=""" Deletes a Load Balancer. """,
    tags=[
        'load_balancer_management',
        'load_balancer_operations',
        'load_balancer_actions',
    ],
)
def delete_load_balancers__id(id: int):
    """
    Delete a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/load_balancers/{id}',
    description=""" Gets a specific Load Balancer object. """,
    tags=['load_balancer_management', 'load_balancer_operations'],
)
def get_load_balancers__id(id: int):
    """
    Get a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/load_balancers/{id}',
    description=""" Updates a Load Balancer. You can update a Load Balancer’s name and a Load Balancer’s labels.

Note that when updating labels, the Load Balancer’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.

Note: if the Load Balancer object changes during the request, the response will be a “conflict” error.
 """,
    tags=['load_balancer_management', 'load_balancer_operations'],
)
def put_load_balancers__id(id: int, body: LoadBalancersIdPutRequest = None):
    """
    Update a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/load_balancers/{id}/actions',
    description=""" Returns all Action objects for a Load Balancer. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter. """,
    tags=['load_balancer_management', 'load_balancer_actions'],
)
def get_load_balancers__id_actions(
    id: int, sort: Optional[Sort20] = None, status: Optional[Status54] = None
):
    """
    Get all Actions for a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/add_service',
    description=""" Adds a service to a Load Balancer.

#### Call specific error codes

| Code                       | Description                                             |
|----------------------------|---------------------------------------------------------|
| `source_port_already_used` | The source port you are trying to add is already in use |
 """,
    tags=['load_balancer_management', 'load_balancer_actions'],
)
def post_load_balancers__id_actions_add_service(
    id: int, body: LoadBalancersIdActionsAddServicePostRequest = None
):
    """
    Add Service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/add_target',
    description=""" Adds a target to a Load Balancer.

#### Call specific error codes

| Code                                    | Description                                                                                           |
|-----------------------------------------|-------------------------------------------------------------------------------------------------------|
| `cloud_resource_ip_not_allowed`         | The IP you are trying to add as a target belongs to a Hetzner Cloud resource                          |
| `ip_not_owned`                          | The IP you are trying to add as a target is not owned by the Project owner                            |
| `load_balancer_not_attached_to_network` | The Load Balancer is not attached to a network                                                        |
| `robot_unavailable`                     | Robot was not available. The caller may retry the operation after a short delay.                      |
| `server_not_attached_to_network`        | The server you are trying to add as a target is not attached to the same network as the Load Balancer |
| `target_already_defined`                | The Load Balancer target you are trying to define is already defined                                  |
 """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'load_balancer_operations',
    ],
)
def post_load_balancers__id_actions_add_target(
    id: int, body: LoadBalancersIdActionsAddTargetPostRequest = None
):
    """
    Add Target
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/attach_to_network',
    description=""" Attach a Load Balancer to a Network.

**Call specific error codes**

| Code                             | Description                                                           |
|----------------------------------|-----------------------------------------------------------------------|
| `load_balancer_already_attached` | The Load Balancer is already attached to a network                    |
| `ip_not_available`               | The provided Network IP is not available                              |
| `no_subnet_available`            | No Subnet or IP is available for the Load Balancer within the network |
 """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'network_management',
        'load_balancer_operations',
    ],
)
def post_load_balancers__id_actions_attach_to_network(
    id: int, body: LoadBalancersIdActionsAttachToNetworkPostRequest = None
):
    """
    Attach a Load Balancer to a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/change_algorithm',
    description=""" Change the algorithm that determines to which target new requests are sent. """,
    tags=['load_balancer_actions', 'load_balancer_management'],
)
def post_load_balancers__id_actions_change_algorithm(
    id: int, body: LoadBalancersIdActionsChangeAlgorithmPostRequest = None
):
    """
    Change Algorithm
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/change_dns_ptr',
    description=""" Changes the hostname that will appear when getting the hostname belonging to the public IPs (IPv4 and IPv6) of this Load Balancer.

Floating IPs assigned to the Server are not affected by this.
 """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'load_balancer_operations',
    ],
)
def post_load_balancers__id_actions_change_dns_ptr(
    id: int, body: LoadBalancersIdActionsChangeDnsPtrPostRequest = None
):
    """
    Change reverse DNS entry for this Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/change_protection',
    description=""" Changes the protection configuration of a Load Balancer. """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'load_balancer_operations',
    ],
)
def post_load_balancers__id_actions_change_protection(
    id: int, body: LoadBalancersIdActionsChangeProtectionPostRequest = None
):
    """
    Change Load Balancer Protection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/change_type',
    description=""" Changes the type (Max Services, Max Targets and Max Connections) of a Load Balancer.

**Call specific error codes**

| Code                         | Description                                                     |
|------------------------------|-----------------------------------------------------------------|
| `invalid_load_balancer_type` | The Load Balancer type does not fit for the given Load Balancer |
 """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'load_balancer_type_management',
        'load_balancer_operations',
    ],
)
def post_load_balancers__id_actions_change_type(
    id: int, body: LoadBalancersIdActionsChangeTypePostRequest = None
):
    """
    Change the Type of a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/delete_service',
    description=""" Delete a service of a Load Balancer. """,
    tags=['load_balancer_management', 'load_balancer_operations'],
)
def post_load_balancers__id_actions_delete_service(
    id: int, body: LoadBalancersIdActionsDeleteServicePostRequest = None
):
    """
    Delete Service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/detach_from_network',
    description=""" Detaches a Load Balancer from a network. """,
    tags=['load_balancer_management', 'load_balancer_actions', 'network_management'],
)
def post_load_balancers__id_actions_detach_from_network(
    id: int, body: LoadBalancersIdActionsDetachFromNetworkPostRequest = None
):
    """
    Detach a Load Balancer from a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/disable_public_interface',
    description=""" Disable the public interface of a Load Balancer. The Load Balancer will be not accessible from the internet via its public IPs.

#### Call specific error codes

| Code                                      | Description                                                                    |
|-------------------------------------------|--------------------------------------------------------------------------------|
| `load_balancer_not_attached_to_network`   |  The Load Balancer is not attached to a network                                |
| `targets_without_use_private_ip`          | The Load Balancer has targets that use the public IP instead of the private IP |
 """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'load_balancer_operations',
    ],
)
def post_load_balancers__id_actions_disable_public_interface(id: int):
    """
    Disable the public interface of a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/enable_public_interface',
    description=""" Enable the public interface of a Load Balancer. The Load Balancer will be accessible from the internet via its public IPs. """,
    tags=[
        'load_balancer_management',
        'load_balancer_operations',
        'load_balancer_actions',
    ],
)
def post_load_balancers__id_actions_enable_public_interface(id: int):
    """
    Enable the public interface of a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/remove_target',
    description=""" Removes a target from a Load Balancer. """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'load_balancer_operations',
    ],
)
def post_load_balancers__id_actions_remove_target(
    id: int, body: LoadBalancersIdActionsRemoveTargetPostRequest = None
):
    """
    Remove Target
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/load_balancers/{id}/actions/update_service',
    description=""" Updates a Load Balancer Service.

#### Call specific error codes

| Code                       | Description                                             |
|----------------------------|---------------------------------------------------------|
| `source_port_already_used` | The source port you are trying to add is already in use |
 """,
    tags=[
        'load_balancer_management',
        'load_balancer_operations',
        'load_balancer_actions',
    ],
)
def post_load_balancers__id_actions_update_service(
    id: int, body: LoadBalancersIdActionsUpdateServicePostRequest = None
):
    """
    Update Service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/load_balancers/{id}/actions/{action_id}',
    description=""" Returns a specific Action for a Load Balancer. """,
    tags=[
        'load_balancer_management',
        'load_balancer_actions',
        'load_balancer_operations',
    ],
)
def get_load_balancers__id_actions__action_id(id: int, action_id: int = ...):
    """
    Get an Action for a Load Balancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/load_balancers/{id}/metrics',
    description=""" You must specify the type of metric to get: `open_connections`, `connections_per_second`, `requests_per_second` or `bandwidth`. You can also specify more than one type by comma separation, e.g. `requests_per_second,bandwidth`.

Depending on the type you will get different time series data:

|Type | Timeseries | Unit | Description |
|---- |------------|------|-------------|
| open_connections | open_connections | number | Open connections |
| connections_per_second | connections_per_second | connections/s | Connections per second |
| requests_per_second | requests_per_second | requests/s | Requests per second |
| bandwidth | bandwidth.in | bytes/s | Ingress bandwidth |
|| bandwidth.out | bytes/s | Egress bandwidth |

Metrics are available for the last 30 days only.

If you do not provide the step argument we will automatically adjust it so that 200 samples are returned.

We limit the number of samples to a maximum of 500 and will adjust the step parameter accordingly.
 """,
    tags=[
        'load_balancer_management',
        'load_balancer_operations',
        'load_balancer_actions',
    ],
)
def get_load_balancers__id_metrics(
    id: int,
    type: Type44 = ...,
    start: str = ...,
    end: str = ...,
    step: Optional[str] = None,
):
    """
    Get Metrics for a LoadBalancer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations',
    description=""" Returns all Location objects. """,
    tags=['location_management'],
)
def get_locations(name: Optional[str] = None):
    """
    Get all Locations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/locations/{id}',
    description=""" Returns a specific Location object. """,
    tags=['location_management'],
)
def get_locations__id(id: int):
    """
    Get a Location
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networks',
    description=""" Gets all existing networks that you have available. """,
    tags=['network_management'],
)
def get_networks(name: Optional[str] = None, label_selector: Optional[str] = None):
    """
    Get all Networks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks',
    description=""" Creates a network with the specified `ip_range`.

You may specify one or more `subnets`. You can also add more Subnets later by using the [add subnet action](https://docs.hetzner.cloud/#network-actions-add-a-subnet-to-a-network). If you do not specify an `ip_range` in the subnet we will automatically pick the first available /24 range for you.

You may specify one or more routes in `routes`. You can also add more routes later by using the [add route action](https://docs.hetzner.cloud/#network-actions-add-a-route-to-a-network).
 """,
    tags=['network_management'],
)
def post_networks(body: NetworksPostRequest = None):
    """
    Create a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/networks/{id}',
    description=""" Deletes a network. If there are Servers attached they will be detached in the background.

Note: if the network object changes during the request, the response will be a “conflict” error.
 """,
    tags=['network_management'],
)
def delete_networks__id(id: int):
    """
    Delete a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networks/{id}',
    description=""" Gets a specific network object. """,
    tags=['network_management'],
)
def get_networks__id(id: int):
    """
    Get a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/networks/{id}',
    description=""" Updates the network properties.

Note that when updating labels, the network’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.

Note: if the network object changes during the request, the response will be a “conflict” error.
 """,
    tags=['network_management'],
)
def put_networks__id(id: int, body: NetworksIdPutRequest = None):
    """
    Update a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networks/{id}/actions',
    description=""" Returns all Action objects for a Network. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter. """,
    tags=['action_management', 'network_management'],
)
def get_networks__id_actions(
    id: int, sort: Optional[Sort20] = None, status: Optional[Status71] = None
):
    """
    Get all Actions for a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks/{id}/actions/add_route',
    description=""" Adds a route entry to a Network.

Note: if the Network object changes during the request, the response will be a “conflict” error.
 """,
    tags=['network_management'],
)
def post_networks__id_actions_add_route(
    id: int, body: NetworksIdActionsAddRoutePostRequest = None
):
    """
    Add a route to a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks/{id}/actions/add_subnet',
    description=""" Adds a new subnet object to the Network. If you do not specify an `ip_range` for the subnet we will automatically pick the first available /24 range for you if possible.

Note: if the parent Network object changes during the request, the response will be a “conflict” error.
 """,
    tags=['network_management'],
)
def post_networks__id_actions_add_subnet(
    id: int, body: NetworksIdActionsAddSubnetPostRequest = None
):
    """
    Add a subnet to a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks/{id}/actions/change_ip_range',
    description=""" Changes the IP range of a Network. IP ranges can only be extended and never shrunk. You can only add IPs at the end of an existing IP range. This means that the IP part of your existing range must stay the same and you can only change its netmask.

For example if you have a range `10.0.0.0/16` you want to extend then your new range must also start with the IP `10.0.0.0`. Your CIDR netmask `/16` may change to a number that is smaller than `16` thereby increasing the IP range. So valid entries would be `10.0.0.0/15`, `10.0.0.0/14`, `10.0.0.0/13` and so on.

After changing the IP range you will have to adjust the routes on your connected Servers by either rebooting them or manually changing the routes to your private Network interface.

Note: if the Network object changes during the request, the response will be a “conflict” error.
 """,
    tags=['network_management'],
)
def post_networks__id_actions_change_ip_range(
    id: int, body: NetworksIdActionsChangeIpRangePostRequest = None
):
    """
    Change IP range of a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks/{id}/actions/change_protection',
    description=""" Changes the protection configuration of a Network.

Note: if the Network object changes during the request, the response will be a “conflict” error.
 """,
    tags=['network_management', 'primary_ip_management'],
)
def post_networks__id_actions_change_protection(
    id: int, body: NetworksIdActionsChangeProtectionPostRequest = None
):
    """
    Change Network Protection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks/{id}/actions/delete_route',
    description=""" Delete a route entry from a Network.

Note: if the Network object changes during the request, the response will be a “conflict” error.
 """,
    tags=['network_management', 'action_management'],
)
def post_networks__id_actions_delete_route(
    id: int, body: NetworksIdActionsDeleteRoutePostRequest = None
):
    """
    Delete a route from a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks/{id}/actions/delete_subnet',
    description=""" Deletes a single subnet entry from a Network. You cannot delete subnets which still have Servers attached. If you have Servers attached you first need to detach all Servers that use IPs from this subnet before you can delete the subnet.

Note: if the Network object changes during the request, the response will be a “conflict” error.
 """,
    tags=['network_management'],
)
def post_networks__id_actions_delete_subnet(
    id: int, body: NetworksIdActionsDeleteSubnetPostRequest = None
):
    """
    Delete a subnet from a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networks/{id}/actions/{action_id}',
    description=""" Returns a specific Action for a Network. """,
    tags=['network_management', 'action_management'],
)
def get_networks__id_actions__action_id(id: int, action_id: int = ...):
    """
    Get an Action for a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/placement_groups',
    description=""" Returns all PlacementGroup objects. """,
    tags=['placement_group_management'],
)
def get_placement_groups(
    sort: Optional[Sort24] = None,
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
    type: Optional[Type52] = None,
):
    """
    Get all PlacementGroups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/placement_groups',
    description=""" Creates a new PlacementGroup.
 """,
    tags=['placement_group_management'],
)
def post_placement_groups(body: PlacementGroupsPostRequest = None):
    """
    Create a PlacementGroup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/placement_groups/{id}',
    description=""" Deletes a PlacementGroup. """,
    tags=['placement_group_management'],
)
def delete_placement_groups__id(id: int):
    """
    Delete a PlacementGroup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/placement_groups/{id}',
    description=""" Gets a specific PlacementGroup object. """,
    tags=['placement_group_management'],
)
def get_placement_groups__id(id: int):
    """
    Get a PlacementGroup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/placement_groups/{id}',
    description=""" Updates the PlacementGroup properties.

Note that when updating labels, the PlacementGroup’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.

Note: if the PlacementGroup object changes during the request, the response will be a “conflict” error.
 """,
    tags=['placement_group_management'],
)
def put_placement_groups__id(id: int, body: PlacementGroupsIdPutRequest = None):
    """
    Update a PlacementGroup
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pricing',
    description=""" Returns prices for all resources available on the platform. VAT and currency of the Project owner are used for calculations.

Both net and gross prices are included in the response.
 """,
    tags=['pricing_info'],
)
def get_pricing():
    """
    Get all prices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/primary_ips',
    description=""" Returns all Primary IP objects. """,
    tags=['primary_ip_management', 'network_management'],
)
def get_primary_ips(
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
    ip: Optional[str] = None,
    sort: Optional[Sort26] = None,
):
    """
    Get all Primary IPs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/primary_ips',
    description=""" Creates a new Primary IP, optionally assigned to a Server.

If you want to create a Primary IP that is not assigned to a Server, you need to provide the `datacenter` key instead of `assignee_id`. This can be either the ID or the name of the Datacenter this Primary IP shall be created in.

Note that a Primary IP can only be assigned to a Server in the same Datacenter later on.

#### Call specific error codes

| Code                          | Description                                                   |
|------------------------------ |-------------------------------------------------------------- |
| `server_not_stopped`          | The specified server is running, but needs to be powered off  |
| `server_has_ipv4`             | The server already has an ipv4 address                        |
| `server_has_ipv6`             | The server already has an ipv6 address                        |
 """,
    tags=['primary_ip_management', 'network_management'],
)
def post_primary_ips(body: PrimaryIpsPostRequest = None):
    """
    Create a Primary IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/primary_ips/{id}',
    description=""" Deletes a Primary IP.

The Primary IP may be assigned to a Server. In this case it is unassigned automatically. The Server must be powered off (status `off`) in order for this operation to succeed.
 """,
    tags=['primary_ip_management', 'network_management'],
)
def delete_primary_ips__id(id: int):
    """
    Delete a Primary IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/primary_ips/{id}',
    description=""" Returns a specific Primary IP object. """,
    tags=['primary_ip_management'],
)
def get_primary_ips__id(id: int):
    """
    Get a Primary IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/primary_ips/{id}',
    description=""" Updates the Primary IP.

Note that when updating labels, the Primary IP's current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.

If the Primary IP object changes during the request, the response will be a “conflict” error.
 """,
    tags=['primary_ip_management', 'action_management'],
)
def put_primary_ips__id(id: int, body: PrimaryIpsIdPutRequest = None):
    """
    Update a Primary IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/primary_ips/{id}/actions/assign',
    description=""" Assigns a Primary IP to a Server.

A Server can only have one Primary IP of type `ipv4` and one of type `ipv6` assigned. If you need more IPs use Floating IPs.

The Server must be powered off (status `off`) in order for this operation to succeed.

#### Call specific error codes

| Code                          | Description                                                   |
|------------------------------ |-------------------------------------------------------------- |
| `server_not_stopped`          | The server is running, but needs to be powered off            |
| `primary_ip_already_assigned` | Primary ip is already assigned to a different server          |
| `server_has_ipv4`             | The server already has an ipv4 address                        |
| `server_has_ipv6`             | The server already has an ipv6 address                        |
 """,
    tags=['primary_ip_management', 'action_management'],
)
def post_primary_ips__id_actions_assign(
    id: int, body: PrimaryIpsIdActionsAssignPostRequest = None
):
    """
    Assign a Primary IP to a resource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/primary_ips/{id}/actions/change_dns_ptr',
    description=""" Changes the hostname that will appear when getting the hostname belonging to this Primary IP. """,
    tags=['primary_ip_management', 'action_management'],
)
def post_primary_ips__id_actions_change_dns_ptr(
    id: int, body: PrimaryIpsIdActionsChangeDnsPtrPostRequest = None
):
    """
    Change reverse DNS entry for a Primary IP
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/primary_ips/{id}/actions/change_protection',
    description=""" Changes the protection configuration of a Primary IP.

A Primary IP can only be delete protected if its `auto_delete` property is set to `false`.
 """,
    tags=['primary_ip_management', 'action_management'],
)
def post_primary_ips__id_actions_change_protection(
    id: int, body: PrimaryIpsIdActionsChangeProtectionPostRequest = None
):
    """
    Change Primary IP Protection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/primary_ips/{id}/actions/unassign',
    description=""" Unassigns a Primary IP from a Server.

The Server must be powered off (status `off`) in order for this operation to succeed.

Note that only Servers that have at least one network interface (public or private) attached can be powered on.

#### Call specific error codes

| Code                              | Description                                                   |
|---------------------------------- |-------------------------------------------------------------- |
| `server_not_stopped`              | The server is running, but needs to be powered off            |
| `server_is_load_balancer_target`  | The server ipv4 address is a loadbalancer target              |
 """,
    tags=['action_management', 'primary_ip_management'],
)
def post_primary_ips__id_actions_unassign(id: int):
    """
    Unassign a Primary IP from a resource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/server_types',
    description=""" Gets all Server type objects. """,
    tags=['server_type_retrieval'],
)
def get_server_types(name: Optional[str] = None):
    """
    Get all Server Types
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/server_types/{id}',
    description=""" Gets a specific Server type object. """,
    tags=['server_type_retrieval', 'server_management'],
)
def get_server_types__id(id: int):
    """
    Get a Server Type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/servers',
    description=""" Returns all existing Server objects """,
    tags=['server_management', 'server_actions'],
)
def get_servers(
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
    sort: Optional[Sort28] = None,
    status: Optional[Status89] = None,
):
    """
    Get all Servers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers',
    description=""" Creates a new Server. Returns preliminary information about the Server as well as an Action that covers progress of creation. """,
    tags=['server_management', 'server_actions'],
)
def post_servers(body: ServersPostRequest = None):
    """
    Create a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/servers/{id}',
    description=""" Deletes a Server. This immediately removes the Server from your account, and it is no longer accessible. """,
    tags=['server_management', 'server_actions'],
)
def delete_servers__id(id: int):
    """
    Delete a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/servers/{id}',
    description=""" Returns a specific Server object. The Server must exist inside the Project """,
    tags=['server_management', 'server_actions'],
)
def get_servers__id(id: int):
    """
    Get a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/servers/{id}',
    description=""" Updates a Server. You can update a Server’s name and a Server’s labels.
Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).
Also note that when updating labels, the Server’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body. """,
    tags=['server_management', 'server_actions'],
)
def put_servers__id(id: int, body: ServersIdPutRequest = None):
    """
    Update a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/servers/{id}/actions',
    description=""" Returns all Action objects for a Server. You can `sort` the results by using the sort URI parameter, and filter them with the `status` parameter. """,
    tags=['action_management', 'server_actions'],
)
def get_servers__id_actions(
    id: int, sort: Optional[Sort30] = None, status: Optional[Status104] = None
):
    """
    Get all Actions for a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/add_to_placement_group',
    description=""" Adds a Server to a Placement Group.

Server must be powered off for this command to succeed.

#### Call specific error codes

| Code                          | Description                                                          |
|-------------------------------|----------------------------------------------------------------------|
| `server_not_stopped`          | The action requires a stopped server                                 |
 """,
    tags=['placement_group_management', 'server_management', 'server_actions'],
)
def post_servers__id_actions_add_to_placement_group(
    id: int, body: ServersIdActionsAddToPlacementGroupPostRequest = None
):
    """
    Add a Server to a Placement Group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/attach_iso',
    description=""" Attaches an ISO to a Server. The Server will immediately see it as a new disk. An already attached ISO will automatically be detached before the new ISO is attached.

Servers with attached ISOs have a modified boot order: They will try to boot from the ISO first before falling back to hard disk.
 """,
    tags=['server_management', 'server_actions', 'iso_management'],
)
def post_servers__id_actions_attach_iso(
    id: int, body: ServersIdActionsAttachIsoPostRequest = None
):
    """
    Attach an ISO to a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/attach_to_network',
    description=""" Attaches a Server to a network. This will complement the fixed public Server interface by adding an additional ethernet interface to the Server which is connected to the specified network.

The Server will get an IP auto assigned from a subnet of type `server` in the same `network_zone`.

Using the `alias_ips` attribute you can also define one or more additional IPs to the Servers. Please note that you will have to configure these IPs by hand on your Server since only the primary IP will be given out by DHCP.

**Call specific error codes**

| Code                             | Description                                                           |
|----------------------------------|-----------------------------------------------------------------------|
| `server_already_attached`        | The server is already attached to the network                         |
| `ip_not_available`               | The provided Network IP is not available                              |
| `no_subnet_available`            | No Subnet or IP is available for the Server within the network        |
| `networks_overlap`               | The network IP range overlaps with one of the server networks         |
 """,
    tags=['network_management', 'server_management', 'server_actions'],
)
def post_servers__id_actions_attach_to_network(
    id: int, body: ServersIdActionsAttachToNetworkPostRequest = None
):
    """
    Attach a Server to a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/change_alias_ips',
    description=""" Changes the alias IPs of an already attached Network. Note that the existing aliases for the specified Network will be replaced with these provided in the request body. So if you want to add an alias IP, you have to provide the existing ones from the Network plus the new alias IP in the request body. """,
    tags=['network_management', 'action_management'],
)
def post_servers__id_actions_change_alias_ips(
    id: int, body: ServersIdActionsChangeAliasIpsPostRequest = None
):
    """
    Change alias IPs of a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/change_dns_ptr',
    description=""" Changes the hostname that will appear when getting the hostname belonging to the primary IPs (IPv4 and IPv6) of this Server.

Floating IPs assigned to the Server are not affected by this.
 """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_change_dns_ptr(
    id: int, body: ServersIdActionsChangeDnsPtrPostRequest = None
):
    """
    Change reverse DNS entry for this Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/change_protection',
    description=""" Changes the protection configuration of the Server. """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_change_protection(
    id: int, body: ServersIdActionsChangeProtectionPostRequest = None
):
    """
    Change Server Protection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/change_type',
    description=""" Changes the type (Cores, RAM and disk sizes) of a Server.

Server must be powered off for this command to succeed.

This copies the content of its disk, and starts it again.

You can only migrate to Server types with the same `storage_type` and equal or bigger disks. Shrinking disks is not possible as it might destroy data.

If the disk gets upgraded, the Server type can not be downgraded any more. If you plan to downgrade the Server type, set `upgrade_disk` to `false`.

#### Call specific error codes

| Code                          | Description                                                          |
|-------------------------------|----------------------------------------------------------------------|
| `invalid_server_type`         | The server type does not fit for the given server or is deprecated   |
| `server_not_stopped`          | The action requires a stopped server                                 |
 """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_change_type(
    id: int, body: ServersIdActionsChangeTypePostRequest = None
):
    """
    Change the Type of a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/create_image',
    description=""" Creates an Image (snapshot) from a Server by copying the contents of its disks. This creates a snapshot of the current state of the disk and copies it into an Image. If the Server is currently running you must make sure that its disk content is consistent. Otherwise, the created Image may not be readable.

To make sure disk content is consistent, we recommend to shut down the Server prior to creating an Image.

You can either create a `backup` Image that is bound to the Server and therefore will be deleted when the Server is deleted, or you can create an `snapshot` Image which is completely independent of the Server it was created from and will survive Server deletion. Backup Images are only available when the backup option is enabled for the Server. Snapshot Images are billed on a per GB basis.
 """,
    tags=['image_management', 'server_management', 'server_actions'],
)
def post_servers__id_actions_create_image(
    id: int, body: ServersIdActionsCreateImagePostRequest = None
):
    """
    Create Image from a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/detach_from_network',
    description=""" Detaches a Server from a network. The interface for this network will vanish. """,
    tags=['server_management', 'network_management', 'server_actions'],
)
def post_servers__id_actions_detach_from_network(
    id: int, body: ServersIdActionsDetachFromNetworkPostRequest = None
):
    """
    Detach a Server from a Network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/detach_iso',
    description=""" Detaches an ISO from a Server. In case no ISO Image is attached to the Server, the status of the returned Action is immediately set to `success` """,
    tags=['iso_management', 'server_management'],
)
def post_servers__id_actions_detach_iso(id: int):
    """
    Detach an ISO from a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/disable_backup',
    description=""" Disables the automatic backup option and deletes all existing Backups for a Server. No more additional charges for backups will be made.

Caution: This immediately removes all existing backups for the Server!
 """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_disable_backup(id: int):
    """
    Disable Backups for a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/disable_rescue',
    description=""" Disables the Hetzner Rescue System for a Server. This makes a Server start from its disks on next reboot.

Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.

Disabling rescue mode will not reboot your Server — you will have to do this yourself.
 """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_disable_rescue(id: int):
    """
    Disable Rescue Mode for a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/enable_backup',
    description=""" Enables and configures the automatic daily backup option for the Server. Enabling automatic backups will increase the price of the Server by 20%. In return, you will get seven slots where Images of type backup can be stored.

Backups are automatically created daily.
 """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_enable_backup(id: int):
    """
    Enable and Configure Backups for a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/enable_rescue',
    description=""" Enable the Hetzner Rescue System for this Server. The next time a Server with enabled rescue mode boots it will start a special minimal Linux distribution designed for repair and reinstall.

In case a Server cannot boot on its own you can use this to access a Server’s disks.

Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.

Enabling rescue mode will not [reboot](https://docs.hetzner.cloud/#server-actions-soft-reboot-a-server) your Server — you will have to do this yourself.
 """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_enable_rescue(
    id: int, body: ServersIdActionsEnableRescuePostRequest = None
):
    """
    Enable Rescue Mode for a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/poweroff',
    description=""" Cuts power to the Server. This forcefully stops it without giving the Server operating system time to gracefully stop. May lead to data loss, equivalent to pulling the power cord. Power off should only be used when shutdown does not work. """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_poweroff(id: int):
    """
    Power off a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/poweron',
    description=""" Starts a Server by turning its power on. """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_poweron(id: int):
    """
    Power on a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/reboot',
    description=""" Reboots a Server gracefully by sending an ACPI request. The Server operating system must support ACPI and react to the request, otherwise the Server will not reboot. """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_reboot(id: int):
    """
    Soft-reboot a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/rebuild',
    description=""" Rebuilds a Server overwriting its disk with the content of an Image, thereby **destroying all data** on the target Server

The Image can either be one you have created earlier (`backup` or `snapshot` Image) or it can be a completely fresh `system` Image provided by us. You can get a list of all available Images with `GET /images`.

Your Server will automatically be powered off before the rebuild command executes.
 """,
    tags=['server_management', 'server_actions', 'image_management'],
)
def post_servers__id_actions_rebuild(
    id: int, body: ServersIdActionsRebuildPostRequest = None
):
    """
    Rebuild a Server from an Image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/remove_from_placement_group',
    description=""" Removes a Server from a Placement Group.
 """,
    tags=['placement_group_management', 'action_management'],
)
def post_servers__id_actions_remove_from_placement_group(id: int):
    """
    Remove from Placement Group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/request_console',
    description=""" Requests credentials for remote access via VNC over websocket to keyboard, monitor, and mouse for a Server. The provided URL is valid for 1 minute, after this period a new url needs to be created to connect to the Server. How long the connection is open after the initial connect is not subject to this timeout. """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_request_console(id: int):
    """
    Request Console for a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/reset',
    description=""" Cuts power to a Server and starts it again. This forcefully stops it without giving the Server operating system time to gracefully stop. This may lead to data loss, it’s equivalent to pulling the power cord and plugging it in again. Reset should only be used when reboot does not work. """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_reset(id: int):
    """
    Reset a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/reset_password',
    description=""" Resets the root password. Only works for Linux systems that are running the qemu guest agent. Server must be powered on (status `running`) in order for this operation to succeed.

This will generate a new password for this Server and return it.

If this does not succeed you can use the rescue system to netboot the Server and manually change your Server password by hand.
 """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_reset_password(id: int):
    """
    Reset root Password of a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/servers/{id}/actions/shutdown',
    description=""" Shuts down a Server gracefully by sending an ACPI shutdown request. The Server operating system must support ACPI and react to the request, otherwise the Server will not shut down. """,
    tags=['server_management', 'server_actions'],
)
def post_servers__id_actions_shutdown(id: int):
    """
    Shutdown a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/servers/{id}/actions/{action_id}',
    description=""" Returns a specific Action object for a Server. """,
    tags=['server_actions', 'server_management'],
)
def get_servers__id_actions__action_id(id: int, action_id: int = ...):
    """
    Get an Action for a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/servers/{id}/metrics',
    description=""" Get Metrics for specified Server.

You must specify the type of metric to get: cpu, disk or network. You can also specify more than one type by comma separation, e.g. cpu,disk.

Depending on the type you will get different time series data

| Type    | Timeseries              | Unit      | Description                                          |
|---------|-------------------------|-----------|------------------------------------------------------|
| cpu     | cpu                     | percent   | Percent CPU usage                                    |
| disk    | disk.0.iops.read        | iop/s     | Number of read IO operations per second              |
|         | disk.0.iops.write       | iop/s     | Number of write IO operations per second             |
|         | disk.0.bandwidth.read   | bytes/s   | Bytes read per second                                |
|         | disk.0.bandwidth.write  | bytes/s   | Bytes written per second                             |
| network | network.0.pps.in        | packets/s | Public Network interface packets per second received |
|         | network.0.pps.out       | packets/s | Public Network interface packets per second sent     |
|         | network.0.bandwidth.in  | bytes/s   | Public Network interface bytes/s received            |
|         | network.0.bandwidth.out | bytes/s   | Public Network interface bytes/s sent                |

Metrics are available for the last 30 days only.

If you do not provide the step argument we will automatically adjust it so that a maximum of 200 samples are returned.

We limit the number of samples returned to a maximum of 500 and will adjust the step parameter accordingly.
 """,
    tags=['server_management'],
)
def get_servers__id_metrics(
    id: int,
    type: Type81 = ...,
    start: str = ...,
    end: str = ...,
    step: Optional[str] = None,
):
    """
    Get Metrics for a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ssh_keys',
    description=""" Returns all SSH key objects. """,
    tags=['ssh_key_management'],
)
def get_ssh_keys(
    sort: Optional[Sort32] = None,
    name: Optional[str] = None,
    fingerprint: Optional[str] = None,
    label_selector: Optional[str] = None,
):
    """
    Get all SSH keys
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ssh_keys',
    description=""" Creates a new SSH key with the given `name` and `public_key`. Once an SSH key is created, it can be used in other calls such as creating Servers. """,
    tags=['ssh_key_management'],
)
def post_ssh_keys(body: SshKeysPostRequest = None):
    """
    Create an SSH key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/ssh_keys/{id}',
    description=""" Deletes an SSH key. It cannot be used anymore. """,
    tags=['ssh_key_management'],
)
def delete_ssh_keys__id(id: str):
    """
    Delete an SSH key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ssh_keys/{id}',
    description=""" Returns a specific SSH key object. """,
    tags=['ssh_key_management'],
)
def get_ssh_keys__id(id: int):
    """
    Get a SSH key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ssh_keys/{id}',
    description=""" Updates an SSH key. You can update an SSH key name and an SSH key labels.

Please note that when updating labels, the SSH key current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
 """,
    tags=['ssh_key_management'],
)
def put_ssh_keys__id(id: str, body: SshKeysIdPutRequest = None):
    """
    Update an SSH key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/volumes',
    description=""" Gets all existing Volumes that you have available. """,
    tags=['volume_management'],
)
def get_volumes(
    status: Optional[Status132] = None,
    sort: Optional[Sort34] = None,
    name: Optional[str] = None,
    label_selector: Optional[str] = None,
):
    """
    Get all Volumes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes',
    description=""" Creates a new Volume attached to a Server. If you want to create a Volume that is not attached to a Server, you need to provide the `location` key instead of `server`. This can be either the ID or the name of the Location this Volume will be created in. Note that a Volume can be attached to a Server only in the same Location as the Volume itself.

Specifying the Server during Volume creation will automatically attach the Volume to that Server after it has been initialized. In that case, the `next_actions` key in the response is an array which contains a single `attach_volume` action.

The minimum Volume size is 10GB and the maximum size is 10TB (10240GB).

A volume’s name can consist of alphanumeric characters, dashes, underscores, and dots, but has to start and end with an alphanumeric character. The total length is limited to 64 characters. Volume names must be unique per Project.

#### Call specific error codes

| Code                                | Description                                         |
|-------------------------------------|-----------------------------------------------------|
| `no_space_left_in_location`         | There is no volume space left in the given location |
 """,
    tags=['volume_management'],
)
def post_volumes(body: VolumesPostRequest = None):
    """
    Create a Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/volumes/{id}',
    description=""" Deletes a volume. All Volume data is irreversibly destroyed. The Volume must not be attached to a Server and it must not have delete protection enabled. """,
    tags=['volume_management'],
)
def delete_volumes__id(id: str):
    """
    Delete a Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/volumes/{id}',
    description=""" Gets a specific Volume object. """,
    tags=['volume_management'],
)
def get_volumes__id(id: int):
    """
    Get a Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/volumes/{id}',
    description=""" Updates the Volume properties.

Note that when updating labels, the volume’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
 """,
    tags=['volume_management'],
)
def put_volumes__id(id: str, body: VolumesIdPutRequest = None):
    """
    Update a Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/volumes/{id}/actions',
    description=""" Returns all Action objects for a Volume. You can `sort` the results by using the sort URI parameter, and filter them with the `status` parameter. """,
    tags=['action_management', 'volume_management'],
)
def get_volumes__id_actions(
    id: int, sort: Optional[Sort36] = None, status: Optional[Status140] = None
):
    """
    Get all Actions for a Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes/{id}/actions/attach',
    description=""" Attaches a Volume to a Server. Works only if the Server is in the same Location as the Volume. """,
    tags=['server_management', 'server_actions', 'volume_management'],
)
def post_volumes__id_actions_attach(
    id: int, body: VolumesIdActionsAttachPostRequest = None
):
    """
    Attach Volume to a Server
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes/{id}/actions/change_protection',
    description=""" Changes the protection configuration of a Volume. """,
    tags=['volume_management'],
)
def post_volumes__id_actions_change_protection(
    id: int, body: VolumesIdActionsChangeProtectionPostRequest = None
):
    """
    Change Volume Protection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes/{id}/actions/detach',
    description=""" Detaches a Volume from the Server it’s attached to. You may attach it to a Server again at a later time. """,
    tags=['volume_management'],
)
def post_volumes__id_actions_detach(id: int):
    """
    Detach Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes/{id}/actions/resize',
    description=""" Changes the size of a Volume. Note that downsizing a Volume is not possible. """,
    tags=['volume_management'],
)
def post_volumes__id_actions_resize(
    id: int, body: VolumesIdActionsResizePostRequest = None
):
    """
    Resize Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/volumes/{id}/actions/{action_id}',
    description=""" Returns a specific Action for a Volume. """,
    tags=['action_management', 'volume_management'],
)
def get_volumes__id_actions__action_id(id: int, action_id: int = ...):
    """
    Get an Action for a Volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
